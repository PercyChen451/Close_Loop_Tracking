# Import relevant libraries
import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import random
import time


kinPressures = np.array([5, 2, 1])/1000
goalCoords = np.array( [.02, 17, 1] )
i_goal = 0
time_prev = 0
tip_prev = 0
beta_prev = 0
omega = np.array([0,0,0])


class RPPR_Kinematics:
    def __init__(self):
        # Initialize arc theta variable which is local to the functions in this class
        self.arcTheta = None

        # Initialize chamber length increments
        self.l1_inc = None
        self.l2_inc = None
        self.l3_inc = None
        
        # finish initializing material and geometric properties here
        self.a = 2          # [mm]      radius
        self.h = 0.0381     # [mm]      film thickness 
        self.E = 7.35       # [N/mm^2]  Young's Modulus 100%
        self.v = 0.5        # []        Poisson's ratio
        self.d = 4.5     # [mm]      balloon center radial distance from backbone
        self.phi_i = 2/3*np.pi
        self.phi_0 = 1/2*np.pi

        self.T1_0 = np.array([[1, 0, 0, self.d*np.cos(self.phi_0)],
                            [0, 1, 0, self.d*np.sin(self.phi_0)],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]]) # define trans matrix for each balloon backbone
        
        self.T2_0 = np.array([[1, 0, 0, self.d*np.cos(self.phi_i + self.phi_0)],
                            [0, 1, 0, self.d*np.sin(self.phi_i + self.phi_0)],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]])
        
        self.T3_0 = np.array([[1, 0, 0, self.d*np.cos(2*self.phi_i + self.phi_0)],
                            [0, 1, 0, self.d*np.sin(2*self.phi_i + self.phi_0)],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]])


    def robotSpecificMapping(self, l1, l2, l3):
        # Convert chamber heights to 3D arc parameters
        arcLen = (l1 + l2 + l3) / 3
        arcPhi = math.atan2((math.sqrt(3)/3.0) * (l2 + l3 - 2*l1), (l2 - l3))
        arcKappa = (2*math.sqrt(l1**2 + l2**2 + l3**2 - l1*l2 - l1*l3 - l2*l3)) / (self.d*(l1+l2+l3))

        return arcLen, arcPhi, arcKappa

    def robotIndependentMapping(self, arcLen, arcPhi, arcKappa):
        # Relate kappa, arc length, and theta
        self.arcTheta = arcKappa * arcLen

        # Convert 3D arc parameters to tip pose transformation matrix
        Tw = np.array([[np.cos(arcPhi)**2 * (np.cos(self.arcTheta)-1)+1, np.sin(arcPhi)*np.cos(arcPhi)*(np.cos(self.arcTheta)-1), np.cos(arcPhi)*np.sin(self.arcTheta), np.cos(arcPhi)*(1-np.cos(self.arcTheta))/arcKappa],\
                            [np.sin(arcPhi)*np.cos(arcPhi)*(np.cos(self.arcTheta)-1), np.cos(arcPhi)**2 * (1-np.cos(self.arcTheta))+np.cos(self.arcTheta), np.sin(arcPhi)*np.sin(self.arcTheta), np.sin(arcPhi)*(1-np.cos(self.arcTheta))/arcKappa],\
                            [-np.cos(arcPhi)*np.sin(self.arcTheta), -np.sin(arcPhi)*np.sin(self.arcTheta), np.cos(self.arcTheta), np.sin(self.arcTheta)/arcKappa],\
                            [0, 0, 0, 1]])
        
        return Tw

    def twoStepMapping(self, l1, l2, l3):
        # Initialize tip position matrix 
        tipCoords = np.zeros((3,1))

        # Calculate tip coordinates:
        # If chamber lengths vary
        if max([l1,l2,l3]) - min([l1,l2,l3]) > 0:
            arcLen, arcPhi, arcKappa = self.robotSpecificMapping(l1, l2, l3)
            Tw = self.robotIndependentMapping(arcLen, arcPhi, arcKappa)
            tipCoords = Tw[0:3,3]

        # If chamber lengths are the same
        else:
            tipCoords = np.array([[0], [0], [l1]])

        return tipCoords
    
    def backbone(self, l1, l2, l3, linspaceParam):
        # Generate length increments for each chamber
        self.l1_inc = np.linspace(0, l1, linspaceParam)
        self.l2_inc = np.linspace(0, l2, linspaceParam)
        self.l3_inc = np.linspace(0, l3, linspaceParam)

        # Initialize matrix of backbone coordinates
        backboneCoords = np.zeros((3, linspaceParam))


        # print("length1",l1)
        # Populate backbone coordinate matrix:
        # If chamber lengths vary
        if max([l1,l2,l3]) - min([l1,l2,l3]) > 0:
            for index2 in range(1, linspaceParam):
                l, phi, kappa = self.robotSpecificMapping(self.l1_inc[index2], self.l2_inc[index2], self.l3_inc[index2])
                Tw_inc = self.robotIndependentMapping(l, phi, kappa)
                backboneCoords[:,index2] = Tw_inc[0:3,3]
        
        # If chamber lengths are the same
        else:
            backboneCoords[2,:] = np.linspace(0, l1, linspaceParam)

        return backboneCoords
    
    def pressureToLength(self, P, linspaceParam):
        # Use input pressure to determine chamber lengths based on timoshenko's model
        # corrected model for fresh SBA, scale = 0.84
        scale = 0.84
        len_c = scale*2*linspaceParam*0.622*self.a*( P*self.a/(self.E*self.h) )**(1/3)
        
        return len_c
    
    def lengths_to_volumes(self, ells, base_height):
        volumes = 100/4667 * (ells - base_height)
        return volumes*1000
    
    def calcJacobian(self, P1, P2, P3):
        # print([P1, P2, P3])
        # Use input chamber pressures to determine jacobian at corresponding state
        #         
        J11 = - (2*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1))/(3*P1**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(1324*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(2/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(3*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))) - (3**(5/6)*14**(1/3)*42**(1/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*4j)/(9*P1**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))
        J12 = - (2*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1))/(3*P2**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (2*42**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(3*P2**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(1324*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(2/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(3*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))) + (79375*42**(1/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*((1324*42**(1/3))/(238125*P2**(2/3)) + (3**(5/6)*14**(1/3)*1324j)/(714375*P2**(2/3)))*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(662*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))
        J13 = - (2*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1))/(3*P3**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) + (2*42**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(3*P3**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*42**(1/3)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(1324*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(2/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(3*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))) - (79375*42**(1/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*((1324*P2**(1/3))/79375 - (1324*P3**(1/3))/79375)*((1324*42**(1/3))/(238125*P3**(2/3)) - (3**(5/6)*14**(1/3)*1324j)/(714375*P3**(2/3)))*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(662*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))

        J21 = (4*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P1**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (2*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P1**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(3972*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (3**(2/3)*14**(2/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*4j)/(9*P1**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (10*3**(5/6)*14**(1/3)*42**(1/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(9*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))
        J22 = - (2*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P2**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (2*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P2**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(3972*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) + (79375*3**(5/6)*14**(1/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*((1324*42**(1/3))/(238125*P2**(2/3)) + (3**(5/6)*14**(1/3)*1324j)/(714375*P2**(2/3)))*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375))/(1986*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (10*3**(5/6)*14**(1/3)*42**(1/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(9*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))
        J23 = - (2*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P3**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (2*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375))/(9*P3**(2/3)*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (79375*3**(5/6)*14**(1/3)*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(3972*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (79375*3**(5/6)*14**(1/3)*self.signM((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*((1324*42**(1/3))/(238125*P3**(2/3)) - (3**(5/6)*14**(1/3)*1324j)/(714375*P3**(2/3)))*(np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625) - 1)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375))/(1986*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)**2*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) - (10*3**(5/6)*14**(1/3)*42**(1/3)*635**(2/3)*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*((1324*P2**(1/3))/79375 - (2648*P1**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(9*np.abs((1324*42**(1/3)*P2**(1/3))/79375 - (1324*42**(1/3)*P3**(1/3))/79375 - (3**(5/6)*14**(1/3)*P1**(1/3)*2648j)/238125 + (3**(5/6)*14**(1/3)*P2**(1/3)*1324j)/238125 + (3**(5/6)*14**(1/3)*P3**(1/3)*1324j)/238125)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))

        J31 = (2*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625))/(3*P1**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) + (79375*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(1324*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(1/3)*635**(2/3)*np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P2**(1/3)/(3*P1**(2/3)) - 2/(3*P1**(1/3)) + P3**(1/3)/(3*P1**(2/3))))/(3*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))
        J32 = (2*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625))/(3*P2**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) + (79375*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(1324*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(1/3)*635**(2/3)*np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P2**(2/3)) - 2/(3*P2**(1/3)) + P3**(1/3)/(3*P2**(2/3))))/(3*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))
        J33 = (2*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625))/(3*P3**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2)) + (79375*np.sin((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(1324*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(3/2)) - (10*42**(1/3)*635**(2/3)*np.cos((2648*42**(1/3)*635**(2/3)*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3))**(1/2))/47625)*((1324*P1**(1/3))/79375 + (1324*P2**(1/3))/79375 + (1324*P3**(1/3))/79375)*(P1**(1/3)/(3*P3**(2/3)) - 2/(3*P3**(1/3)) + P2**(1/3)/(3*P3**(2/3))))/(3*(P1**(2/3) + P2**(2/3) + P3**(2/3) - P1**(1/3)*P2**(1/3) - P1**(1/3)*P3**(1/3) - P2**(1/3)*P3**(1/3)))


        Jr = np.array([[J11, J12, J13],
                  [J21, J22, J23],
                  [J31, J32, J33]])
        return Jr

    def calcPosition(self, l1, l2, l3):
        r_ = np.array([0, 0, 0])
        return r_

    def signM(self, x):
        sign_x = x/np.abs(x)
        return sign_x
    
    def backbone_inv(self, tip_pose, linspaceParam):
        '''Use catesian coords of the robot tip as input and output
        the corresponding backbone coords parametrices by some number
        of segments (linspaceParam)'''
        # extract cartesian coords from tip_pose
        x = tip_pose[0]
        y = tip_pose[1]
        z = tip_pose[2]

        # Calculate generalized coords from cartesian coords
        r = (x**2 + y**2 + z**2)/(2*(x**2 + y**2)**(1/2))
        phi = -2*np.arctan( (x - (x**2 + y**2)**(1/2)) / y )
        theta = 2*np.arctan( (x**2 + y**2)**(1/2) / z)

        # Calculate robot specific coordinates
        l = r*theta
        kappa = 1/r
        # phi = phi

        backboneCoords = np.zeros( (3, linspaceParam) )
        l_vector = np.linspace(0,l,linspaceParam)

        for ii in range(1, linspaceParam):
            Tw_inc = self.robotIndependentMapping(l_vector[ii], phi, kappa)
            backboneCoords[:,ii] = Tw_inc[0:3,3]
        
        T_tip = self.robotIndependentMapping(l, phi, kappa)

        # TODO: FINAliZE IK BY ADDING FUCNTION IN(r, l, k) AND OUT(l1(p), l2(p), l3(p))
        # this will finalize IK, which will give p1,p2,p3 required to REACH position x,y,z ---------------------------------------------------------------------------------
        # use matlab sims to solve, should be rel straightforward 

        # TODO: Create additonal funciton that will use volumes (steps) as system inputs, this could lead to more stable and repeatable results!
        # (low level PID controller would be more stable due to (mostly) linear relationship between steps and stroke)
        # might need to create a custon polyfit to steps and stroke

        # TODO: for FK, include damping to Jinv to handle singularities:
        # Jinv = JT(JJT + lambdaI)^(_1) whwre lambda is a small pos value
        return (backboneCoords, r, phi, theta, T_tip)
    
    def generate_circle(self, radius, z_height, num_points=100):
        """ Generate points for a circle parallel to xy plane"""
        # Generate angle values between 0 and 2pi using numpy linspace
        thetha_v = np.linspace(0, 2 * np.pi, num_points)
        # Parametric equations for the circle in 3D space
        circleCoords = np.zeros((3,num_points))

        circleCoords[0,:] = radius * np.cos(thetha_v)
        circleCoords[1,:] = radius * np.sin(thetha_v)

        # circleCoords = self.rotate_axis(circleCoords, -30)

        circleCoords[2,:] += z_height  # Z is constant
        
        return circleCoords
    
    def rotate_axis (self, axis, coords, angle_deg):
        # Convert the angle to radians
        angle_rad = np.radians(angle_deg)


        
        rotation_matrix = 1
        
        if axis=='x':
            # Rotation matrix for rotation around the X-axis
            rotation_matrix = np.array([
            [1, 0, 0],
            [0, np.cos(angle_rad), -np.sin(angle_rad)],
            [0, np.sin(angle_rad), np.cos(angle_rad)]])
        elif axis=='y':
            # Rotation matrix for rotation around the Y-axis
            rotation_matrix = np.array([
            [np.cos(angle_rad), 0, np.sin(angle_rad)],
            [0, 1, 0],
            [-np.sin(angle_rad), 0, np.cos(angle_rad)]])
        elif axis=='z':
            # Rotation matrix for rotation around the Y-axis
            rotation_matrix = np.array([
            [np.cos(angle_rad), -np.sin(angle_rad), 0],
            [np.sin(angle_rad), np.cos(angle_rad), 0],
            [0, 0, 1]])

        # Apply the rotation matrix
        rotated_points = np.dot(rotation_matrix, coords)

        return rotated_points    
    
    def load_path(self, file_name):
        f = open(file_name, 'r')
        line1 = f.readline().rstrip().split(',')
        line2 = f.readline().rstrip().split(',')
        line3 = f.readline().rstrip().split(',')
        f.close()

        # print(line1)

        x_coords = [float(i) for i in line1]
        y_coords = [float(i) for i in line2]
        z_coords = [float(i) for i in line3]

        # path_coords = np.array([x_coords, y_coords, z_coords]) - np.array([[9], [12], [8]])
        path_coords = np.array([x_coords, y_coords, z_coords])

        path_coords = self.rotate_axis( 'y', path_coords, -40)
        # path_coords = self.rotate_axis( 'x', path_coords, +30)
        
        
        path_coords = self.rotate_axis( 'z', path_coords, 120+90)
        path_coords = path_coords + np.array([[-12], [5], [0]])
        
        scale = 0.7
        return path_coords[:,::]*scale
        # return self.rotate_axis( path_coords[:,::10], -40)

    def generate_3d_circle(self, points, num_points):
        """
        Generate a circular path in 3D space from three given points on the circle.

        Parameters:
            points (np.ndarray): A 3x3 numpy array where each column represents
                                the x, y, z coordinates of a point on the circle.
            num_points (int): The number of points to generate along the circle.

        Returns:
            np.ndarray: A 3xN numpy array of x, y, z coordinates for the generated path.
        """
        if points.shape != (3, 3):
            raise ValueError("Input points must be a 3x3 numpy array.")

        # Extract the three points
        p1, p2, p3 = points.T

        # Compute the normal vector to the plane of the circle
        normal = np.cross(p2 - p1, p3 - p1)
        normal = normal / np.linalg.norm(normal)

        # Compute the center of the circle
        mid1 = (p1 + p2) / 2
        mid2 = (p2 + p3) / 2
        dir1 = np.cross(normal, p2 - p1)
        dir2 = np.cross(normal, p3 - p2)

        A = np.vstack([dir1, -dir2]).T
        b = mid2 - mid1
        # Solve using least squares
        t, _, _, _ = np.linalg.lstsq(A, b, rcond=None)
        center = mid1 + t[0] * dir1

        # Radius of the circle
        radius = np.linalg.norm(p1 - center)/2
        # radius = np.linalg.norm(p1 - center)

        # Generate parametric angles
        angles = np.linspace(0, 2 * np.pi, num_points)

        # Find orthogonal vectors for the circle's plane
        u = (p1 - center) / radius / 2
        v = np.cross(normal, u)

        # Generate the points on the circle
        circle_points = center[:, np.newaxis] + radius * (np.cos(angles) * u[:, np.newaxis] + np.sin(angles) * v[:, np.newaxis])

        return circle_points
    
    def steps_to_length(self, s1, s2, s3):
        v1, v2, v3 = 4.1910E-05*s1,4.1910E-05*s2, 4.1910E-05*s3 
        l1, l2, l3 = 45.67*v1,  45.67*v2,  45.67*v3

        return l1, l2, l3
    
    def volume_to_length(self, v1, v2, v3):
        l1, l2, l3 = 45.67*v1,  45.67*v2,  45.67*v3

        return l1, l2, l3

    def volumes_to_pressures(self, v1, v2, v3):
        p1 = 57.9486*v1**3  +123.5743*v1**2 -17.7039*v1  + 1.8930
        p2 = 57.9486*v2**3  +123.5743*v2**2 -17.7039*v2  + 1.8930
        p3 = 57.9486*v3**3  +123.5743*v3**2 -17.7039*v3  + 1.8930

        return p1, p2, p3
    
    def pressureToVolume(self, pressures):
        '''In: pressues in kpa
        out: volume as a fucntion of pressures in mL
        '''
        # print(pressures)
        # print(pressures[0])

        v1 = self.signM(pressures[0])*0.161*np.abs(pressures[0])**(0.333)
        v2 = self.signM(pressures[1])*0.161*np.abs(pressures[1])**(0.333)
        v3 = self.signM(pressures[2])*0.161*np.abs(pressures[2])**(0.333)

        return np.array([v1, v2, v3])
    
    def calcJacobianVolume(self, v1, v2, v3): 
        J11 = (50*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*((4567*v2)/100 - (4567*v3)/100)*(v2 - 2*v1 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (600*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (30000*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v2 - 2*v1 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) - (120000*3**(1/2)*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))

        J12 = (50*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*((4567*v2)/100 - (4567*v3)/100)*(v1 - 2*v2 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (600*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (600*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (30000*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v1 - 2*v2 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) + (30000*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(18*v2 - 18*v3 + 2*3**(1/2)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))

        J13 = (600*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (600*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) + (50*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*((4567*v2)/100 - (4567*v3)/100)*(v1 + v2 - 2*v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (30000*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v1 + v2 - 2*v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) + (30000*((4567*v2)/100 - (4567*v3)/100)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(18*v3 - 18*v2 + 2*3**(1/2)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))


        J21 = (400*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (200*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (120000*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) + (50*3**(1/2)*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v2 - 2*v1 + v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(13701*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (10000*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v2 - 2*v1 + v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2))

        J22 = (10000*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(18*v2 - 18*v3 + 2*3**(1/2)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (200*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (200*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) + (50*3**(1/2)*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 - 2*v2 + v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(13701*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (10000*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v1 - 2*v2 + v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2))

        J23 = (10000*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(18*v3 - 18*v2 + 2*3**(1/2)*(3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3))*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(3/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (200*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) - (200*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100))/(4567*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2)) + (50*3**(1/2)*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 + v2 - 2*v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(13701*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2)) - (10000*3**(1/2)*(np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600) - 1)*(v1 + v2 - 2*v3)*((4567*v2)/100 - (4567*v1)/50 + (4567*v3)/100)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(20857489*(9*(v2 - v3)**2 + (3**(1/2)*v2 - 2*3**(1/2)*v1 + 3**(1/2)*v3)**2)**(1/2)*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2))


        J31 = (2*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600))/(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2) + (100*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v2 - 2*v1 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) + (np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v2 - 2*v1 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(6*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2))

        J32 = (2*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600))/(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2) + (100*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 - 2*v2 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) + (np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 - 2*v2 + v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(6*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2))

        J33 = (2*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600))/(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2) + (100*np.sin((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 + v2 - 2*v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(3/2)) + (np.cos((4567*(v1**2 - v1*v2 - v1*v3 + v2**2 - v2*v3 + v3**2)**(1/2))/600)*(v1 + v2 - 2*v3)*((4567*v1)/100 + (4567*v2)/100 + (4567*v3)/100))/(6*(- v1**2 + v1*v2 + v1*v3 - v2**2 + v2*v3 - v3**2))


        J = np.array([[J11, J12, J13],
                  [J21, J22, J23],
                  [J31, J32, J33]])
        return J
    
    def jacobian_from_lengths():
        '''best approximation for true SBA shape!!!!'''
        return
    
    def get_PCC_backbone(self, revoluteVec, curveParam, is2D = False, T_prev = np.eye(4)):
        '''Inputs: Location of n revolute joints connected by rigid links,
        curve parametrization int, Initial frame of 0th link.
        Outputs: PCC backbone from 0th to nth link with n links'''
        n_links = revoluteVec.shape[1]
        # print(n_links)
        # print(revoluteVec)
        
        # PCC_backbone = np.zeros( (4, n_links*curveParam) )
        PCC_backbone = np.zeros( (4,1) )
        # print()

        for n in range(1, n_links):
            joint = revoluteVec[:,n]
            if is2D:
                joint = np.array([joint[0], 0, joint[1]]) # convert to 3d for compatibility rest of kinematics
            
            (back_coords, _, _, _, T_prev) = self.backbone_inv(joint, curveParam, T_prev)
            # PCC_backbone[:,(n-1)*curveParam:n*curveParam] = back_coords
            # print(back_coords)
            # print((n-1)*curveParam, ',', n*curveParam)
            PCC_backbone = np.hstack((PCC_backbone, back_coords))



        return PCC_backbone

    def backbone_inv(self, tip_pose, linspaceParam, Tg = np.eye(4)):
        '''Use catesian coords of the robot tip as input and output
        the corresponding backbone coords parametrices by some number
        of segments (linspaceParam)'''
        # TODO: This inv from xyx to phi, theta, r, needs a MAJOR revision and
        # confirmation. The commented out code was from matlab (might be accurate)
        # The active code is from online resources, concerns about accuracy

        # extract cartesian coords from tip_pose
        # x = tip_pose[0]
        # y = tip_pose[1]
        # z = tip_pose[2]

        # # Calculate generalized coords from cartesian coords
        # r = (x**2 + y**2 + z**2)/(2*(x**2 + y**2)**(1/2))
        # theta = 2*np.arctan( (x**2 + y**2)**(1/2) / z)

        # phi = 0
        # if y != 0:
        #     phi = -2*np.arctan( (x - (x**2 + y**2)**(1/2)) / y )

        # # Calculate robot specific coordinates
        # l = r*theta
        # kappa = 1/r
        # # phi = phi

        # Extract Cartesian coordinates
        # R = Tg[0:3,0:3]

        # print(tip_pose)
        # print(np.ones((1,1)))
        tip_pose_rot = np.linalg.inv(Tg) @  np.hstack( (tip_pose, 1)) 
        x, y, z = tip_pose_rot[0:3]
        
        # Compute theta using atan2 to ensure correct quadrant selection
        r_proj = np.sqrt(x**2 + y**2)  # Projection onto the xy-plane
        theta = 2 * np.arctan2(r_proj, z)  # Arc angle

        # Compute radius of curvature r (avoid division by zero)
        if r_proj == 0:
            r = np.inf  # Treat as a straight line
        else:
            # r = (x**2 + y**2 + z**2) / (2 * r_proj)
            r = (x**2 + y**2 + z**2)/(2*(x**2 + y**2)**(1/2))

        # Compute azimuth angle phi robustly
        phi = np.arctan2(y, x)

        # Compute curvature (kappa), ensuring sign switching when needed
        kappa = np.sign(theta) / r if r != np.inf else 0  # Avoid division by zero

        # Compute arc length
        l = r * theta if r != np.inf else np.sqrt(x**2 + y**2 + z**2)  # Straight line case

        backboneCoords = np.zeros( (3, linspaceParam) )
        l_vector = np.linspace(0,l,linspaceParam)

        Tw_inc = np.eye(4)
        for ii in range(2, linspaceParam):
            Tw_inc = self.robotIndependentMapping(l_vector[ii], phi, kappa)
            backboneCoords[:,ii] = Tw_inc[0:3,3]
        
        # TODO: FINAliZE IK BY ADDING FUCNTION IN(r, l, k) AND OUT(l1(p), l2(p), l3(p))
        # this will finalize IK, which will give p1,p2,p3 required to REACH position x,y,z ---------------------------------------------------------------------------------
        # use matlab sims to solve, should be rel straightforward 

        # TODO: Create additonal funciton that will use volumes (steps) as system inputs, this could lead to more stable and repeatable results!
        # (low level PID controller would be more stable due to (mostly) linear relationship between steps and stroke)
        # might need to create a custon polyfit to steps and stroke

        # TODO: for FK, include damping to Jinv to handle singularities:
        # Jinv = JT(JJT + lambdaI)^(_1) whwre lambda is a small pos value


        backboneCoords = np.vstack( (backboneCoords, np.ones((1,linspaceParam))) )

        return (Tg @ backboneCoords, r, phi, theta, Tg @ Tw_inc)
    
    
    def get_chamber_transformations(self, l1, l2, l3, n=20):
        back1, back2, back3 = np.zeros((3, n)), np.zeros((3, n)), np.zeros((3, n))
        l1_inc = np.linspace(0, l1, n)
        l2_inc = np.linspace(0, l2, n)
        l3_inc = np.linspace(0, l3, n)

        # Preallocate transformation arrays
        T1 = [None] * n
        T2 = [None] * n
        T3 = [None] * n
        T1[0], T2[0], T3[0] = self.T1_0.copy(), self.T2_0.copy(), self.T3_0.copy()

        if max([l1, l2, l3]) - min([l1, l2, l3]) > 0.0001:
            for ind in range(1, n):
                s, phi, kappa = self.robotSpecificMapping(l1_inc[ind], l2_inc[ind], l3_inc[ind])
                Tw_inc = self.robotIndependentMapping(s, phi, kappa)

                T1_w = Tw_inc @ self.T1_0
                T2_w = Tw_inc @ self.T2_0 
                T3_w = Tw_inc @ self.T3_0

                T1[ind] = T1_w
                T2[ind] = T2_w
                T3[ind] = T3_w

                back1[:, ind] = T1_w[:3, 3]
                back2[:, ind] = T2_w[:3, 3]
                back3[:, ind] = T3_w[:3, 3]

        else:
            for i in range(n):
                T1[i] = self.T1_0.copy()
                T2[i] = self.T2_0.copy()
                T3[i] = self.T3_0.copy()

                T1[i][2, 3] = l1_inc[i]
                T2[i][2, 3] = l2_inc[i]
                T3[i][2, 3] = l3_inc[i]

            back1[2, :] = l1_inc
            back2[2, :] = l2_inc
            back3[2, :] = l3_inc

        return T1, T2, T3, back1, back2, back3
    
    def get_jacobian_actuated(self, u_ells, link_lens, beta_angles, len_e = 0, d=4):
        # ell1, ell2 = u_ells
        # b1, b2, b3 = beta_angles
        # L1, L2, L3 = link_lens

        # estimate length for rigid link systems runnig along each chamber as the current chamber lengths under load
        ell1, ell2 = np.sum(link_lens + 2*d*np.sin(beta_angles)), np.sum(link_lens - 2*d*np.sin(beta_angles))

        # print(ell1, ell2)

        # J = np.array([ [np.sin(b1 + b2)/6 + np.sin(b1)/6 + np.sin(b1 + b2 + b3)/6, np.sin(b1 + b2)/6 + np.sin(b1)/6 + np.sin(b1 + b2 + b3)/6],
        #             [np.cos(b1 + b2)/6 + np.cos(b1)/6 + np.cos(b1 + b2 + b3)/6, np.cos(b1 + b2)/6 + np.cos(b1)/6 + np.cos(b1 + b2 + b3)/6] ])
        
        ''' This J assumes ell1 and ell2 equally contribute to link_lens and beta_lens (as in the unloaded state, Bo and Lo)
            This is NOT the case. We need to consider how the external force affects the shape (ie Bi and Li) AND
            us this as part of the computation for Ja (down below). One potential idea is simply accounting for how Bi and Li are
            fucntions of the unloaded states B0 and L0. 
                We can define such fucntion Bi =c*Bo -> c = Bi/Bo. 
                Recognize that Bo and Bi are fucntions of l1 and l2
                Then compute Ja = dr(c*Bo,d*Lo)/d(l1, l2)
            This should account for the effect of the external forces on the new shape AND how the shape is a function l1, l2'''
        

        if len_e != 0:
            J = np.array( [ [np.sin((ell1 - ell2)/(4*d))/6 + np.sin((ell1 - ell2)/(12*d))/6 + np.sin((5*ell1 - 5*ell2)/(12*d))/6 + (np.cos((ell1 - ell2)/(4*d))*(ell1/6 + ell2/6))/(4*d) + (np.cos((ell1 - ell2)/(12*d))*(ell1/6 + ell2/6))/(12*d) + (5*np.cos((5*ell1 - 5*ell2)/(12*d))*(len_e + ell1/6 + ell2/6))/(12*d), np.sin((ell1 - ell2)/(4*d))/6 + np.sin((ell1 - ell2)/(12*d))/6 + np.sin((5*ell1 - 5*ell2)/(12*d))/6 - (np.cos((ell1 - ell2)/(4*d))*(ell1/6 + ell2/6))/(4*d) - (np.cos((ell1 - ell2)/(12*d))*(ell1/6 + ell2/6))/(12*d) - (5*np.cos((5*ell1 - 5*ell2)/(12*d))*(len_e + ell1/6 + ell2/6))/(12*d)],
                         [np.cos((ell1 - ell2)/(4*d))/6 + np.cos((ell1 - ell2)/(12*d))/6 + np.cos((5*ell1 - 5*ell2)/(12*d))/6 - (np.sin((ell1 - ell2)/(4*d))*(ell1/6 + ell2/6))/(4*d) - (np.sin((ell1 - ell2)/(12*d))*(ell1/6 + ell2/6))/(12*d) - (5*np.sin((5*ell1 - 5*ell2)/(12*d))*(len_e + ell1/6 + ell2/6))/(12*d), np.cos((ell1 - ell2)/(4*d))/6 + np.cos((ell1 - ell2)/(12*d))/6 + np.cos((5*ell1 - 5*ell2)/(12*d))/6 + (np.sin((ell1 - ell2)/(4*d))*(ell1/6 + ell2/6))/(4*d) + (np.sin((ell1 - ell2)/(12*d))*(ell1/6 + ell2/6))/(12*d) + (5*np.sin((5*ell1 - 5*ell2)/(12*d))*(len_e + ell1/6 + ell2/6))/(12*d)] ])
            # print("---------------------------------------------")
            return J
        
        J = np.array([[(np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)**2)/6 + (np.cos((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)**2*(ell1/6 + ell2/6))/(12*d) - (2*np.sin((ell1 - ell2)/(6*d))*np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)*(ell1/6 + ell2/6))/(3*d), (np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)**2)/6 - (np.cos((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)**2*(ell1/6 + ell2/6))/(12*d) + (2*np.sin((ell1 - ell2)/(6*d))*np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(6*d)) + 1)*(ell1/6 + ell2/6))/(3*d)],
                      [(np.cos((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(3*d)) + 1))/6 - (2*np.cos((ell1 - ell2)/(12*d))*np.sin((ell1 - ell2)/(3*d))*(ell1/6 + ell2/6))/(3*d) - (np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(3*d)) + 1)*(ell1/6 + ell2/6))/(12*d),                                      (np.cos((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(3*d)) + 1))/6 + (2*np.cos((ell1 - ell2)/(12*d))*np.sin((ell1 - ell2)/(3*d))*(ell1/6 + ell2/6))/(3*d) + (np.sin((ell1 - ell2)/(12*d))*(2*np.cos((ell1 - ell2)/(3*d)) + 1)*(ell1/6 + ell2/6))/(12*d)]])
        
        
        return J
    
    
    def jacobian_y(self, beta, link_lens, len_e = 0):
        """
        Computes the Jacobian matrix for a planar three-link manipulator, theta wrt y axis.
        """
        # uses current Beta and link lens
        l1_, l2_, l3_ = link_lens
        beta0, beta1, beta2 = beta

        # Compute partial derivatives
        J11 = l1_ * np.cos(beta0) + l2_ * np.cos(beta0 + beta1) + l3_ * np.cos(beta0 + beta1 + beta2)
        J12 = l2_ * np.cos(beta0 + beta1) + l3_ * np.cos(beta0 + beta1 + beta2)
        J13 = (l3_ + len_e) * np.cos(beta0 + beta1 + beta2)

        J21 = -l1_ * np.sin(beta0) - l2_ * np.sin(beta0 + beta1) - l3_ * np.sin(beta0 + beta1 + beta2)
        J22 = -l2_ * np.sin(beta0 + beta1) - l3_ * np.sin(beta0 + beta1 + beta2)
        J23 = -(l3_ + len_e) * np.sin(beta0 + beta1 + beta2)

        # Construct the Jacobian matrix
        J = np.array([[J11, J12, J13],
                    [J21, J22, J23]])
    
        return J
    
    # Compute joint torques due to external force
    def revolute_torque(self, beta, link_lens, force, len_e = 0):
        """Convert external force at end-effector into joint torques"""
        J_T = self.jacobian_y(beta, link_lens, len_e).T  # Transpose of Jacobian
        return J_T @ force  #  = J^T * F

    # Compute link normal forces (eventually should combine with external_torque() and compute J = dr/dq where q = [b1, b2, b3, l1, l2, l3])
    def link_force(self, beta, link_lens, force):
        """Convert external force at end-effector into joint torques"""
        link_forces = np.zeros(3)

        # print("beta",beta)
        # print("force", link_forces)
        # print
        for i in range(0, len(beta)):
            # print("beta_i", beta[0:i+1])
            b_i = np.sum( beta[0:i+1] ) # current angle
            link_forces[i] = force[0]*np.sin(b_i) + force[1]*np.cos(b_i)

        return link_forces
    
    def compute_q_dynamics(self, K, links_0, betas_0, del_force, omega, len_e = 0):
        """ In the quasi-statics case, no grav, assume K*theta = T = J_T*F
        Use current system beta, current link lens, delta force"""
        Kaa, Kuu = K[0:3, 0:3], K[3:, 3:]
        # Baa, Buu = B[0:3, 0:3], B[3:, 3:]
        Baa, Buu = np.diag([0.01, 0.01, 0.01]), np.diag([0.05, 0.05, 0.05])

        
        torques = self.revolute_torque(betas_0, links_0, del_force, len_e)
        forces = self.link_force(betas_0, links_0, del_force)

        # with damping
        beta_new = betas_0 + np.linalg.inv(Kuu) @ (torques - Buu @ omega)
        # beta_new = betas_0 + np.linalg.inv(Kuu) @ torques

        
        del_lens = np.linalg.inv(Kaa) @ forces
        # del_lens =np.zeros(3)
        link_lens_new = links_0 + del_lens


        return link_lens_new, beta_new
    
    def q_no_load(self, u_ells, n=3, d = 4.0):
        l1, l2 = u_ells

        # arc params from chamber lenghts (steady state)
        R = (d*(l1 + l2))/(l1 - l2)
        theta = (l1 - l2)/(2*d)
        s = l1/2 + l2/2

        
        arc_lens = np.ones(n)/n * s  # length of each constant curve
        theta_curves = np.ones(n)/n * theta # angle of each piecewise const curve

        beta_scale = np.array( [1/2 if i==0 else 1 for i in range(len(theta_curves))] )# scaling factors from theta to betas obtained from geometric relationship.
        
        beta_steady = theta_curves*beta_scale # Initial joint angles rel to y axis/ vertical axis (n_links*2-1)
        lens_steady = 2*np.sin(theta_curves/2)/theta_curves*arc_lens # Rigid Link lengths [mm]

        # print("u_ells:", u_ells)
        # print("s:",s)
        # print("theta:",theta)
        # print("arc_lens:",arc_lens)
        # print("theta_curves:", theta_curves)


        return np.hstack((lens_steady, beta_steady))

    def get_revolute_backbone(self, betas, lenghts, len_e = 0 ):
        '''return three segment rigid link backbone'''
        x0 = 0
        y0 = 0

        x1 = lenghts[0] * np.sin(betas[0])
        y1 = lenghts[0] * np.cos(betas[0])

        x2 = x1 + lenghts[1] * np.sin(betas[0] + betas[1])
        y2 = y1 + lenghts[1] * np.cos(betas[0] + betas[1])

        x3 = x2 + lenghts[2] * np.sin(betas[0] + betas[1] + betas[2])
        y3 = y2 + lenghts[2] * np.cos(betas[0] + betas[1] + betas[2])

        if len_e != 0:
            xe = x3 + len_e * np.sin(betas[0] + betas[1] + betas[2] + betas[2] / 2)
            ye = y3 + len_e * np.cos(betas[0] + betas[1] + betas[2] + betas[2] / 2)
            return np.array([[x0, x1, x2, x3, xe],[y0, y1, y2, y3, ye]])
        
        return np.array([[x0, x1, x2, x3],[y0, y1, y2, y3]])
    


def external_force(t, F, freq = 0.25):
    Fx, Fy = F
    return np.array([Fx - Fx * np.sin(freq*t*2.0*np.pi), Fy - Fy * np.sin(freq*t*2.0*np.pi)])


def invKinUpdate(frame, path_line, goal_mark, rev_line, pcc_line, force_line, len1_mark, len2_mark, 
                 num_pts, kin, circleCoords, K):
    global kinPressures
    global goalCoords
    global i_goal
    global q, q0, u_ells
    global time_prev, tip_prev, beta_prev, omega

    time_now = time.time()
    dt =time_now - time_prev
    time_prev = time_now
    
    # compute q_0, config variables under  no external load)
    q0 =  kin.q_no_load(u_ells)
    len_e = 3
    # len_e = 0

    # Force = np.array([0.0,-.5])
    Force = external_force(time_now, [0, -.5], 0)

    # compute q (config variables under external load)
    links_now, beta_now = kin.compute_q_dynamics(K, q0[0:3], q0[3:], Force, omega, len_e)
    omega = (beta_now - beta_prev)/dt
    # print("links:", links_now)
    # print("betas:", beta_now)

    revoluteVecDamp = kin.get_revolute_backbone(beta_now, links_now, len_e)
    pcc_coords = kin.get_PCC_backbone(revoluteVecDamp[:,0:4], num_pts, True)

    # goalCoords = np.array([-12 - 5*np.sin(.5*2*np.pi*time_now), 28+5*np.sin(.5*2*np.pi*time_now)])
    goalCoords = circleCoords[:,i_goal]
    tipCoords = revoluteVecDamp[:,-1]
    tip_vel = (tipCoords - tip_prev)/dt
    error = goalCoords - tipCoords
    # print("tip_vel:",tip_vel)
    # print("tipCoords:", tipCoords)
    # print("goal_coords:", goalCoords)
    print('error:', np.linalg.norm(error))

    
    # ------------inverse kinematics-----------
    # Calculate Jacobian with regularization
    
    try:
        # Calculate Jacobian with regularization
        J = kin.get_jacobian_actuated(u_ells, links_now, beta_now, len_e)
        # Add small regularization to prevent singular matrices
        regularization = 1e-6 * np.eye(J.shape[1])
        Ja_inv = np.linalg.pinv(J.T @ J + regularization) @ J.T
        rate_base = 0.2
        rate_fb = rate_base if np.linalg.norm(error) > 1 else rate_base + rate_base*(1 - np.linalg.norm(error) )
        rate_ff = 0.0001
        delta_u = np.real(rate_fb*Ja_inv.dot(error.T)) + np.real( rate_ff*Ja_inv.dot(np.zeros(2)-tip_vel.T) )

    except np.linalg.LinAlgError:
        # If SVD fails
        print("SVD failed to converge - using previous command")
        delta_u = np.zeros(2)  # Or np.random.normal(0, 0.01, 2)


    # print("ffw term:", np.real(rate_ff*Ja_inv.dot(tip_vel.T) ) )
    # print("fb term:", np.real(rate_fb*Ja_inv.dot(error.T)))
    # print("delta_u", delta_u)

    # update system inputs
    u_ells = np.clip( u_ells + delta_u, 0, 50)

    # if the robot has reached the first point along the circle move on to the next
    if np.linalg.norm(error) < 0.5:
        print("reached goal with final coords:", tipCoords)
        if i_goal < len(circleCoords[0,:])-1:
            i_goal += 1
        else:
            i_goal = 0



    # Get visual force vector at tip of curve for visualization
    force_coords = np.array([revoluteVecDamp[:,-1], revoluteVecDamp[:,-1] + Force*15])

    # Updating plot elements directly without clearing
    path_line.set_data(circleCoords[0,:], circleCoords[1,:])
    goal_mark.set_data([goalCoords[0]], [goalCoords[1]])
    rev_line.set_data(revoluteVecDamp[0, :], revoluteVecDamp[1, :])
    pcc_line.set_data(pcc_coords[0, :], pcc_coords[2, :])
    force_line.set_data(force_coords[:, 0], force_coords[:, 1]) 
    len1_mark.set_data([1, 1], [0, u_ells[0]])
    len2_mark.set_data([2, 2], [0, u_ells[1]])
    
    beta_prev = beta_now
    tip_prev = tipCoords
    return path_line, goal_mark, rev_line, pcc_line, force_line, len1_mark, len2_mark



# Main function (for testing)
def main():
    global q, q0, u_ells, time_prev, beta_prev, omega
    # TODO: add test cases for jacobian, compare to matlab for all quadrants!
    # import stl to show SBA sim tracing trail on model? https://pypi.org/project/numpy-stl/

    # Call and define CC kinematics class
    kin = RPPR_Kinematics()

    # Define backbone discretization
    linspaceParam = 20

    # generate circle path offset in z, with radius r and paramtrized into n pts
    # pathCoords = np.array([[-5, 1, 5, 10],[15, 20, 20, 15]])
    # pathCoords = np.array([[-15, -10, -5, -1, 1, 5, 10, 15],[15, 15, 15, 15, 15, 15, 15, 15]])
    # pathCoords = np.array([[   0.01, -15,   -13,   -11,    -9,    -7,    -5,    -3,    -1,     1,     3,     5,     7,     9,    11,    13,    15],
    #                        [    15, 10.4772,    14.2736,   16.5758,   18.1909,   19.3527,   20.1658,   20.6844,   20.9374,   20.9374,   20.6844,   20.1658,    19.3527,   18.1909,   16.5758,    14.2736,    10.4772]])

    pathCoords = np.array([[   0.01, -15,   -13,   -11,    -9,    -7,    -5,    -3,    -1,     1,     3,     5,     7,     9,    11,    13,    15],
                           [    25, 20.4772,    24.2736,   26.5758,   28.1909,   29.3527,   30.1658,   30.6844,   30.9374,   30.9374,   30.6844,   30.1658,    29.3527,   28.1909,   26.5758,    24.2736,    20.4772]])


    # Starting Config
    u_ells = np.array([25, 30])
    K = np.diag([.2, .2, .2, 15, 15, 15])
    q0 = kin.q_no_load(u_ells)
    q = kin.q_no_load(u_ells)

    print("q0:", q0)
    print("q:", q)

    tip_prev = np.array([5,10])
    beta_prev = np.array([0.1, 0.2, 0.2])


    # ----------------Initialize figure and axes with blit support------------------
    fig = plt.figure(figsize = (12,5))

    # Comment ON to disable subplots
    ax1 = fig.add_subplot(1, 2, 1)
    ax2 = fig.add_subplot(1, 2, 2)

    # add markers
    path_line, = ax1.plot([],[],'-o', color = 'tab:blue', label='path_coords', markersize = 6)
    goal_mark, = ax1.plot(pathCoords[0,:], pathCoords[1,:], '.', color='tab:red', markersize = 5, label='goal_point')
    rev_line, = ax1.plot([], [], '--', color='tab:gray', label='Revolute', linewidth = 2)
    pcc_line, = ax1.plot([], [], '-', color='tab:orange', label='PCC',  linewidth = 3)
    force_line, = ax1.plot([], [], '-', color='tab:green', label='force', linewidth = 2)

    len1_mark, = ax2.plot([], [], '-', color='tab:blue', label='chamber 1', linewidth = 2)
    len2_mark, = ax2.plot([], [], '-', color='tab:green', label='chamber 1', linewidth = 2)

    # set axis limits
    ax1.set_xlim([-25, 25])
    ax1.set_ylim([-0, 50])
    ax1.legend()
    ax1.set_xlabel('X-axis (mm)')
    ax1.set_ylabel('Y-axis (mm)')
    ax1.set_aspect('equal')

    # set axis limits
    ax2.set_xlim([0, 3])
    ax2.set_ylim([-0, 50])
    ax2.legend()
    ax2.set_xlabel('chamber # ()')
    ax2.set_ylabel('chamber lengths (mm)')
    # ax2.set_aspect('equal')

    # ----------time tracker
    time_start = time.time()
    time_prev = time_start - 0.1
    # -------------Animation
    anim = animation.FuncAnimation(
        fig, invKinUpdate, fargs=(path_line, goal_mark, rev_line, pcc_line, force_line, 
                                  len1_mark, len2_mark, linspaceParam, 
                                  kin, pathCoords, K),
        cache_frame_data=False, interval=20, blit=True
    )
    plt.tight_layout()
    plt.show()  # Show the plot window

# Run Main function
if __name__ == '__main__':
    main()

